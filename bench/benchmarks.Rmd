---
title: "vroom"
output: rmarkdown::github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(vroom)
```

vroom is an experiment for a future version of readr (2.0), or a possible
extension package.

It stems from the observation that
IO is not the bottle neck in parsing delimited datasets, rather (re)-allocating
memory and parsing the values into R data types (particularly for characters)
takes the bulk of the time.

It relies on the Altrep framework available in R 3.5 to provide lazy / delayed
parsing of values in delimited files.

## How it works

The initial reading of the file simply records the locations of each individual
record, the actual values are not read into R. Altrep vectors are
created for each column in the data which hold a pointer to the index and the
memory mapped file. When these vectors are indexed the value is read from the
memory mapping.

This means initial reading is extremely fast, in the example below it is ~ 1/4
the time of the multi-threaded `data.table::fread()`. Sampling operations
are likewise extremely fast, as only the data actually included in the sample
is read. This means things like the tibble print method, calling `head()`,
`tail()` `x[sample(), ]` etc. have very low overhead.

Filtering also can be fast, only the columns included in the filter itself have
to be fully read across the entire dataset, only the filtered rows need to be
read from the remaining columns.

(*N.B. currently the dplyr implementation
materializes the all numeric vectors when using `filter()` or `sample_n()`, so these cases are not as
fast as they could otherwise be*).

This approach also allows you to work with data that is larger than memory. As
long as you are careful to avoid materializing the entire dataset at once it
can be efficiently queried and subset.

Once a particular vector is fully materialized the speed for all subsequent
operations should be identical to a normal R vector.

There is also lots of possible speed improvements available. The indexer could be highly
parallelized, as it does not rely on R data structures at all. The index could
also be stored on disk, which would make re-reading the file at a later time
basically instantaneous. Materializing non-character vectors could also be
parallelized.

## Dataset

```{r include = FALSE}
file <- here::here("trip_fare_1.tsv")

library(fs)
data_size <- fs:::format.fs_bytes(file_info(link_path(file))$size)

x <- vroom(file)

filtered_rows <- sum(x$payment_type == "UNK")
```

The dataset used in these benchmarks is from FOIA/FOILed Taxi Trip Data from
the NYC Taxi and Limousine Commission 2013, originally posted at
<http://chriswhong.com/open-data/foil_nyc_taxi/>. It is also hosted on
[archive.org](https://archive.org/details/nycTaxiTripData2013).

The first table trip_fare_1.csv was converted to tsv and saved as
trip_fare_1.tsv, It is `r data_size` in size.

```{r, echo = FALSE}
dplyr::glimpse(x)
```

## Benchmarks

The benchmark `base` uses `vroom` with base functions for subsetting.
`dplyr` uses `vroom` to read the file and dplyr functions to subset.
`data.table` uses `fread()` to read the file and `data.table` functions to
subset and `readr` uses `readr` to read the file and `dplyr` to subset.

The following operations are performed.

  - The data is read
  - `print()`
  - `head()`
  - `tail()`
  - Sampling 100 random rows
  - Filtering for "UNK" payment, this is `r filtered_rows` rows (`r scales::percent(filtered_rows / nrow(x))` of total).

```{r run_benchmark, cache = TRUE}
vroom_base <- function(file) {
  library(vroom)
  list(
    bench::system_time(x <- vroom(file)),
    bench::system_time(print(x)),
    bench::system_time(head(x)),
    bench::system_time(tail(x)),
    bench::system_time(x[sample(NROW(x), 100), ]),
    bench::system_time(x[x$payment_type == "UNK", ])
  )
}

vroom_dplyr <- function(file) {
  library(vroom)
  library(dplyr)
  list(
    bench::system_time(x <- vroom(file)),
    bench::system_time(print(x)),
    bench::system_time(head(x)),
    bench::system_time(tail(x)),
    bench::system_time(sample_n(x, 100)),
    bench::system_time(filter(x, payment_type == "UNK"))
  )
}

data.table <- function(file) {
  library(data.table)
  list(
    bench::system_time(x <- data.table::fread(file)),
    bench::system_time(print(x)),
    bench::system_time(head(x)),
    bench::system_time(tail(x)),
    bench::system_time(x[sample(NROW(x), 100), ]),
    bench::system_time(x[x$payment_type == "UNK", ])
  )
}

readr <- function(file) {
  library(readr)
  library(dplyr)
  list(
    bench::system_time(x <- read_tsv(file)),
    bench::system_time(print(x)),
    bench::system_time(head(x)),
    bench::system_time(tail(x)),
    bench::system_time(sample_n(x, 100)),
    bench::system_time(filter(x, payment_type == "UNK"))
  )
}

read.delim <- function(file) {
  list(
    bench::system_time(x <- read.delim(file)),
    bench::system_time(print(x)),
    bench::system_time(head(x)),
    bench::system_time(tail(x)),
    bench::system_time(x[sample(NROW(x), 100), ]),
    bench::system_time(x[x$payment_type == "UNK", ])
  )
}

times <- list(
  vroom_base = callr::r(vroom_base, list(file = here::here("trip_fare_1.tsv"))),
  vroom_dplyr = callr::r(vroom_dplyr, list(file = here::here("trip_fare_1.tsv"))),
  data.table = callr::r(data.table, list(file = here::here("trip_fare_1.tsv"))),
  readr = callr::r(readr, list(file = here::here("trip_fare_1.tsv"))),
  read.delim = callr::r(read.delim, list(file = here::here("trip_fare_1.tsv")))
)
```

```{r, include = FALSE}
library(purrr)
library(tidyr)
library(dplyr)
library(forcats)

tm_df <- map_dfr(times, function(x) {
  ops <- c("read", "print", "head", "tail", "sample", "filter")
  tibble::tibble(
    op = factor(ops, levels = ops),
    process = map_dbl(x, "process"),
    real = map_dbl(x, "real")
  )
  }, .id = "package") %>%
  mutate(package = fct_inorder(package)) %>%
  gather(type, time, -package, -op)

saveRDS(tm_df, here::here("bench", "timings.Rds"))
```

```{r, echo = FALSE, warning = FALSE}
library(gt)
tm_df %>% dplyr::filter(op == "read", type == "real") %>% select(package, time) %>% gt::gt() %>% fmt_number(vars(time)) %>% tab_header("Real time to read the file", "(base and dplyr both use `vroom`, so are equivalent)")
```

```{r, echo = FALSE, warning = FALSE}
tm_df %>% group_by(package) %>% dplyr::filter(type == "real") %>% tally(wt = time) %>% rename("time" = "n") %>% gt::gt() %>% fmt_number(vars(time)) %>% tab_header("Total time for all operations")
```

Graph of timings, note because data.table operations use multiple cores the
processor time is often much higher than the real time.

```{r, fig.height = 8, fig.width=10, warning = FALSE}
library(ggplot2)
tm_df %>%
  mutate(package = fct_inorder(sub("_", "\n", package))) %>%
  ggplot() +
  geom_segment(y = 0, aes(x = package, xend = package, yend = time, alpha = type), color = "grey50") +
    geom_point(aes(x = package, y = time, color = type)) +
    facet_wrap(vars(op), scales = "free") +
    bench::scale_y_bench_time(base = NULL) +
    theme(legend.position = "bottom")
```

```{r}
sessioninfo::package_info(c("vroom", "readr", "dplyr", "data.table"), dependencies = FALSE)
```
